var y=Object.create;var l=Object.defineProperty;var q=Object.getOwnPropertyDescriptor;var I=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,O=Object.prototype.hasOwnProperty;var _=t=>l(t,"__esModule",{value:!0});var $=(t,e,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of I(e))!O.call(t,n)&&n!=="default"&&l(t,n,{get:()=>e[n],enumerable:!(i=q(e,n))||i.enumerable});return t},b=t=>$(_(l(t!=null?y(w(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var s=b(require("@actions/core")),o=b(require("@actions/github")),c=b(require("util"));R();async function R(){var t;try{T("GITHUB_TOKEN");const e=o.default.getOctokit(process.env.GITHUB_TOKEN),{owner:i,repo:n}=o.default.context.repo,a={title:s.default.getInput("title"),body:s.default.getInput("body"),head:s.default.getInput("head").replace(/^refs\/heads\//,""),base:s.default.getInput("base").replace(/^refs\/heads\//,""),label:s.default.getInput("label",{required:!0}),draft:s.default.getInput("draft")==="true"};s.default.debug(`Inputs: ${(0,c.inspect)(a)}`);const{data:r,error:p}=await E(e,a.head,a.base,a.label);if(s.default.info(p?"Didn't find existing pull request, creating new.":"Found existing pull request, updating"),p){const{data:f}=await e.rest.repos.compareCommitsWithBasehead({owner:i,repo:n,basehead:`${a.base}...${a.head}`});if(f.total_commits<=0){const{data:g}=await e.rest.repos.listPullRequestsAssociatedWithCommit({owner:i,repo:n,commit_sha:o.default.context.sha}),u=g.filter(d=>d.state==="closed"&&d.labels.find(h=>h.name===a.label)&&d.title===a.title);u.length<=0||((t=u[0])==null?void 0:t.number)==null?s.default.info("No commits between base and head, cancelling operation"):(s.default.info("Found singleton PR merged in request."),s.default.setOutput("id",u[0].id),s.default.setOutput("number",u[0].number));return}s.default.debug("Creating pull request");const m=await e.rest.pulls.create({owner:i,repo:n,title:a.title,body:a.body,head:a.head,base:a.base,draft:a.draft});r.id=m.data.id,r.number=m.data.number,s.default.debug("Adding label to pull request"),await e.rest.issues.addLabels({owner:i,repo:n,issue_number:r.number,labels:[a.label.trim()]})}else s.default.debug("Updating pull request"),await e.rest.pulls.update({owner:i,repo:n,pull_number:r.number,title:a.title,body:a.body});s.default.setOutput("id",r.id),s.default.setOutput("number",r.number)}catch(e){s.default.info((0,c.inspect)(e)),s.default.setFailed(e==null?void 0:e.message)}}function T(...t){let e=!1;return t.forEach(i=>{process.env[i]==null&&(e=!0,s.default.setFailed(`${i} is not configured. Make sure you made it available to your action`))}),e}async function E(t,e,i,n){const a=`repo:${process.env.GITHUB_REPOSITORY} is:pr is:open head:${e} base:${i} label:${n}`,{data:r}=await t.rest.search.issuesAndPullRequests({q:a});return r.total_count>0?{data:{id:r.items[0].id,number:r.items[0].number},error:!1}:{data:{id:void 0,number:void 0},error:!0}}
